pub mod file_manipulation{    
    const HEADER: &str = "<!-- this file was generated with TASKmd 
git repository : https://github.com/democraz20/taskmd
! DO NOT EDIT THIS FILE MANUALLY !
-->

# Tasks \n\n";

    const FOOTER: &str = "\n> Made with [TASKmd](https://github.com/democraz20/taskmd)";

    const FILENAME: &str = "TASK.md";

    use std::fs;
    use std::fs::OpenOptions;
    use std::io::Write;

    pub fn index_tasks() -> Vec<String> {
        let contents = fs::read_to_string("TASK.md").expect("Unable to read file");
        let contents = contents.split("\n");
        let mut contents: Vec<String> = contents.map(String::from).collect::<Vec<_>>();
        for _ in 0..7 {
            contents.remove(0);
        }
        for _ in 0..2 {
            contents.remove(contents.len() - 1);
        }
        contents
    }

    pub fn write_to_file_edit(tasks: &Vec<String>, edit_index: usize, edit_status: bool) {
        let error_mes = "could not write to file";
        let mut file = OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .truncate(true)
            .open(FILENAME)
            .unwrap();

        //its gotta be like that
        file.write_all(HEADER.as_bytes()).expect(error_mes);
        
        for (ind, ele) in tasks.iter().enumerate() {
            if ind == edit_index-1 {
                if !edit_status { //false
                    file.write_all(b" - [ ] ").expect(error_mes);
                    file.write_all(ele.as_bytes()).expect(error_mes);
                } else {
                    file.write_all(b" - [x] ").expect(error_mes);
                    file.write_all(ele.as_bytes()).expect(error_mes);
                }
            }
            else {
                file.write_all(ele.as_bytes()).expect(error_mes);
            }
            file.write_all(b"\n").expect(error_mes);        
        }
        file.write_all(FOOTER.as_bytes()).expect(error_mes);
    }

    pub fn write_to_file(tasks: &Vec<String>){
        let error_mes = "could not write to file";
        let mut file = OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .truncate(true)
            .open(FILENAME)
            .unwrap();

        file.write_all(HEADER.as_bytes()).expect(error_mes);    
        for i in tasks {
            file.write_all(i.as_bytes()).expect(error_mes);
            file.write_all(b"\n").expect(error_mes);
        }
        file.write_all(FOOTER.as_bytes()).expect(error_mes);
    }
}